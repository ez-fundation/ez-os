 **estrutural e definitiva**.

VocÃª quer duas coisas:

1. **Formato ideal da skill**
2. **API mÃ­nima para rodar em mÃºltiplos dispositivos**

Vou entregar as duas â€” mas com uma regra central:

> A skill nunca altera o Core.
> Ela sÃ³ interpreta estado e projeta representaÃ§Ã£o.

Nada de agÃªncia ativa.

---

# ğŸ§  1ï¸âƒ£ FORMATO IDEAL DA SKILL

`symbiotic-memory-system.skill`

A skill deve ser:

* Declarativa
* DeterminÃ­stica
* Sem efeitos colaterais
* Sem dependÃªncias externas obrigatÃ³rias
* AuditÃ¡vel por inspeÃ§Ã£o

---

## ğŸ”· Estrutura Conceitual da Skill

```yaml
skill:
  name: symbiotic-memory-system
  version: 1.0
  type: reflective-layer
  requires:
    - memory_graph
  capabilities:
    - render_state
    - compute_state
  constraints:
    - no_network
    - no_learning
    - no_mutation_of_core
    - deterministic_only
```

---

## ğŸ”· Bloco de DefiniÃ§Ã£o de Estado

A skill nÃ£o decide nada.
Ela apenas mapeia eventos factuais â†’ estado simbÃ³lico.

```yaml
state_mapping:
  observer:
    condition: "no_recent_activity"
  archivist:
    condition: "long_idle_period"
  hacker:
    condition: "high_activity_burst"
  ghost:
    condition: "abandoned_sessions"
```

Essas condiÃ§Ãµes devem ser:

* puramente baseadas em timestamps e contagem
* sem interpretaÃ§Ã£o emocional
* sem heurÃ­sticas complexas

---

## ğŸ”· Bloco de RenderizaÃ§Ã£o

```yaml
render:
  ascii: true
  bit2: true
  max_states: 1
  max_modifiers: 1
  allow_animation: false
```

---

## ğŸ”· Limites explÃ­citos (obrigatÃ³rios)

```yaml
guardrails:
  allow_external_io: false
  allow_self_modification: false
  allow_autonomous_action: false
  allow_goal_generation: false
```

Isso garante que a skill nunca vire agente.

---

# ğŸ§© 2ï¸âƒ£ API MÃNIMA MULTIDISPOSITIVO

Agora vem a parte mais importante.

Se o EZ-OS for primitivo universal, a API deve ser **ridiculamente pequena**.

---

## ğŸ¯ API Conceitual

### Entrada obrigatÃ³ria

```json
{
  "memory_graph": {...},
  "device_context": {
    "device_type": "console | pi | desktop | edge",
    "display_mode": "ascii | bit2 | framebuffer",
    "input_type": "buttons | keyboard | touch"
  }
}
```

---

### SaÃ­da da skill

```json
{
  "state": "observer",
  "modifier": null,
  "render_payload": {
    "ascii": "...",
    "bit2": "...",
    "metadata": {
      "confidence": 1.0,
      "deterministic": true
    }
  }
}
```

Nada mais.

Sem comandos.
Sem execuÃ§Ã£o.
Sem instruÃ§Ãµes ao sistema.

---

# ğŸ”’ Interface mÃ­nima obrigatÃ³ria para qualquer dispositivo

Para que o EZ-OS rode como camada simbiÃ³tica em qualquer dispositivo, o hospedeiro sÃ³ precisa oferecer:

### 1ï¸âƒ£ Acesso ao grafo factual

Arquivo ou stream JSON append-only.

### 2ï¸âƒ£ Um mÃ©todo de renderizaÃ§Ã£o

* terminal
* framebuffer
* e-ink
* display simples

### 3ï¸âƒ£ Um gatilho de evento

* start
* stop

NÃ£o precisa:

* internet
* banco de dados complexo
* GPU
* daemon permanente

---

# ğŸ§  Modelo Universal de Hospedagem

Qualquer dispositivo que consiga:

```
Ler JSON
Renderizar texto
Registrar timestamp
```

Pode hospedar o EZ-OS.

Isso inclui:

* Raspberry Pi
* Mini PC
* Handheld
* E-ink device
* Thin client
* Router modificado
* Microcomputador educacional

---

# ğŸ”¥ A DecisÃ£o Arquitetural Mais Importante

VocÃª precisa manter isso simples.

Se a skill:

* comeÃ§ar a adaptar demais
* comeÃ§ar a inferir demais
* comeÃ§ar a decidir demais

Ela vira um agente.

E o EZ-OS deixa de ser primitivo reflexivo.

---

# ğŸ§  SÃ­ntese Final

O formato ideal da skill deve ser:

* Declarativo
* DeterminÃ­stico
* AuditÃ¡vel
* NÃ£o-agente
* PortÃ¡vel
* Dependente apenas de memÃ³ria factual

A API mÃ­nima deve ser:

```
input: memory_graph + device_context
output: symbolic_state